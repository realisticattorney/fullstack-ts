type Mutation {
  createTweet(userId: String!, body: String!): Tweet!
  #what this is going to amount to when we start using this on the client is the parenthesis around the arguments are the same as the ones in the schema
}
input FavoriteInput {
  userId: String!
  tweetId: String!
} #sort of a reusable object-type 

type Query {
  currentUser: User!
  suggestions: [Suggestion!]!
  tweets: [Tweet!]!
  # in our case everyone sees eveyones tweets
}
type User {
  id: String!
  name: String!
  handle: String!
  coverUrl: String!
  avatarUrl: String!
  createdAt: String!
  updatedAt: String!
  stats: UserStats #nullable field. // as-needed basis
  favorites: [Favorite!] #an array of favorites/likes. favorites can be null instead of an array. but if you get an array, it wont be null. 
}
type Suggestion {
  name: String!
  handle: String!
  avatarUrl: String!
  reason: String!
}

type UserStats { ##followers, tweets, following that we will pretend to get optionally
  #that's why it's not part of the User type
  tweetCount: Int!
  followingCount: Int!
  followerCount: Int!
}
type Tweet {
  id: String!
  body: String!
  createdAt: String!
  updatedAt: String!
  author: User
  stats: TweetStats
  favoritedBy: [User!] #an array of favorites/likes. favorites can be null instead of an array. but if you get an array, it wont be null.
}

type TweetStats {
  favoriteCount: Int!
  retweetCount: Int!
  commentCount: Int!
}

type Favorite {
  id: String!
  tweet: Tweet! #Favorite refers to tweet but tweet does not refers to favorite. So we're not exposing it both ways. It's not a requirement. It's depends on your needs.
  user: User!
  createdAt: String!
  updatedAt: String!
} ##favorites will involve 2 mutations. favorite is the join table of tweet and user. a user can like many tweets and a tweet can be like by many users. 

##like Query, mutation is a top level collection of resolvers.


